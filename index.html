<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Keyword Scanner â€” Word/Excel (10 uploads)</title>
  <style>
    :root { --bg:#f5f6fb; --card:#ffffff; --ink:#1a2134; --muted:#5d6783; --accent:#3b6ee7; --bad:#d34242; --ok:#2f9c62; }
    html, body { height: 100%; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji"; color: var(--ink); background: var(--bg); }
    .wrap { max-width: 1100px; margin: 32px auto; padding: 0 16px 64px; }
    .title { font-size: clamp(20px, 3vw, 32px); font-weight: 400; letter-spacing: .3px; margin-bottom: 16px; }
    .panel { background: var(--card); border: 1px solid rgba(17,24,39,.08); border-radius: 16px; padding: 16px; box-shadow: 0 12px 24px rgba(15,23,42,.08); }
    .grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 12px; }
    .slot { display:flex; align-items:center; justify-content:space-between; gap:12px; padding: 10px 12px; border: 1px dashed rgba(17,24,39,.12); border-radius: 12px; background: rgba(59,110,231,.05); }
    .slot label { font-size: 13px; color: var(--muted); }
    .slot input[type=file] { flex: 1; border: 1px solid rgba(17,24,39,.1); padding: 6px; border-radius: 8px; background: rgba(255,255,255,.85); color: var(--ink); }
    .slot input[type=file]::file-selector-button { margin-right: 10px; border: none; background: var(--accent); color: #f8f9ff; padding: 6px 10px; border-radius: 8px; font-weight: 600; cursor: pointer; }
    .note { font-size: 12px; color: var(--muted); }
    .controls { display: grid; grid-template-columns: 1fr auto; gap: 12px; align-items: center; margin: 16px 0; }
    textarea { width: 100%; min-height: 80px; border-radius: 12px; border: 1px solid rgba(17,24,39,.12); padding: 10px 12px; background: rgba(59,110,231,.04); color: var(--ink); }
    button.primary { background: var(--ok); color: #f8f9ff; border: none; border-radius: 12px; padding: 12px 18px; font-weight: 600; cursor: pointer; }
    button.primary:disabled { opacity: .6; cursor: not-allowed; }
    button.secondary { background: var(--accent); color: #f8f9ff; border: none; border-radius: 12px; padding: 12px 18px; font-weight: 600; cursor: pointer; }
    button.secondary:disabled { opacity: .6; cursor: not-allowed; }
    button.reset { background: #ffffff; color: var(--muted); border: 1px solid rgba(17,24,39,.12); border-radius: 12px; padding: 12px 18px; font-weight: 600; cursor: not-allowed; transition: background-color .2s, color .2s; }
    button.reset:not(:disabled) { background: #7b1e1e; color: #f8f9ff; border: none; cursor: pointer; }
    .results { margin-top: 20px; }
    .results .panel + .panel { margin-top: 16px; }
    table { width: 100%; border-collapse: collapse; border-radius: 12px; overflow: hidden; }
    thead th { text-align: left; font-size: 13px; text-transform: uppercase; letter-spacing: .08em; color: var(--muted); background: rgba(59,110,231,.08); padding: 10px 10px; border-bottom: 1px solid rgba(17,24,39,.08); }
    tbody td { padding: 12px 10px; border-bottom: 1px solid rgba(17,24,39,.08); vertical-align: top; }
    .pill { display:inline-flex; align-items:center; gap:8px; padding: 4px 8px; border-radius: 999px; background: rgba(59,110,231,.08); font-size: 12px; color: var(--ink); }
    .ok { background: rgba(47,156,98,.12); color: #1a6a40; }
    .bad { background: rgba(211,66,66,.12); color: #8b1d1d; }
    code.snip { background: rgba(15,23,42,.08); padding: 2px 6px; border-radius: 8px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; color: var(--ink); }
    .footer { margin-top: 28px; color: var(--muted); font-size: 12px; }
    .legend { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .cols2x5 { display:grid; grid-template-columns: repeat(2, 1fr); gap: 12px; }
    .col { display:grid; grid-template-rows: repeat(5, auto); gap: 12px; }
    .panel-title { font-weight: 700; margin-bottom: 12px; font-size: 15px; }
    .checklist { display:flex; flex-direction:column; gap: 10px; }
    .checklist label { display:flex; align-items:center; gap: 10px; font-size: 14px; color: var(--ink); }
    .checklist input[type=checkbox] { width: 18px; height: 18px; accent-color: var(--accent); }
    .check-actions { margin-top: 16px; display:flex; gap: 10px; }
    @media (max-width: 800px) { .grid, .cols2x5 { grid-template-columns: 1fr; } }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="title">Keyword Scanner</div>

    <div class="panel" aria-label="File uploads">
      <div class="cols2x5" role="group" aria-label="File inputs (10)">
        <div class="col">
          <div class="slot"><label>File 1</label><input class="filebox" type="file" accept=".docx,.xlsx" aria-label="File 1 (docx/xlsx)" /></div>
          <div class="slot"><label>File 2</label><input class="filebox" type="file" accept=".docx,.xlsx" aria-label="File 2 (docx/xlsx)" /></div>
          <div class="slot"><label>File 3</label><input class="filebox" type="file" accept=".docx,.xlsx" aria-label="File 3 (docx/xlsx)" /></div>
          <div class="slot"><label>File 4</label><input class="filebox" type="file" accept=".docx,.xlsx" aria-label="File 4 (docx/xlsx)" /></div>
          <div class="slot"><label>File 5</label><input class="filebox" type="file" accept=".docx,.xlsx" aria-label="File 5 (docx/xlsx)" /></div>
        </div>
        <div class="col">
          <div class="slot"><label>File 6</label><input class="filebox" type="file" accept=".docx,.xlsx" aria-label="File 6 (docx/xlsx)" /></div>
          <div class="slot"><label>File 7</label><input class="filebox" type="file" accept=".docx,.xlsx" aria-label="File 7 (docx/xlsx)" /></div>
          <div class="slot"><label>File 8</label><input class="filebox" type="file" accept=".docx,.xlsx" aria-label="File 8 (docx/xlsx)" /></div>
          <div class="slot"><label>File 9</label><input class="filebox" type="file" accept=".docx,.xlsx" aria-label="File 9 (docx/xlsx)" /></div>
          <div class="slot"><label>File 10</label><input class="filebox" type="file" accept=".docx,.xlsx" aria-label="File 10 (docx/xlsx)" /></div>
        </div>
      </div>
      <div class="note" style="margin-top:8px;">Note: Legacy <code>.doc</code> and <code>.xls</code> are not supported. Convert to .docx or .xlsx before uploading.</div>
    </div>

    <div class="panel" style="margin-top:16px;" aria-labelledby="checkfor-label">
      <div id="checkfor-label" class="panel-title">Check For</div>
      <div class="checklist" role="group" aria-labelledby="checkfor-label">
        <label><input class="term-group" type="checkbox" value="admin" checked />Administration-Flagged Words &amp; Phrases</label>
        <label><input class="term-group" type="checkbox" value="ai" />Indicators of Artificial Intelligence Use</label>
      </div>
      <div class="check-actions">
        <button id="go" class="primary">Analyze Files</button>
        <button id="download" class="secondary">Download Word Lists</button>
        <button id="download-report" class="secondary" disabled>Download Report</button>
        <button id="reset" class="reset" disabled>Reset Form</button>
      </div>
    </div>

    <div id="results" class="results"></div>

    <div class="footer">
      <div>All processing happens locally in your browser. No documents or data are uploaded or saved online.</div>
    </div>
  </div>

  <!-- External libs -->
  <script src="https://unpkg.com/mammoth@1.6.0/mammoth.browser.min.js"></script>
  <script src="https://unpkg.com/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <script>
    const fileBoxes = Array.from(document.querySelectorAll('.filebox'));
    const btn = document.getElementById('go');
    const downloadBtn = document.getElementById('download');
    const downloadReportBtn = document.getElementById('download-report');
    const resetBtn = document.getElementById('reset');
    const resultsDiv = document.getElementById('results');
    let latestReportRows = null;

    const ADMIN_TERMS = `
2S
2S+
Accessibility
Accessible
Activism
Activist
Activists
Advocacy
Advocate
Advocates
Affirm
Affirming
Affirming care
Allied
All-inclusive
Ally
Allyship
Anti-racism
Antiracist
Anti-racist
Assigned at birth
Assigned female at birth
Assigned male at birth
At risk
At-risk
Barrier
Barriers
Belong
Belonging
Bias
Biased
Biased toward
Biases
Biases toward
Biases towards
Biologically female
Biologically male
BIPOC
Birthing people
Black
Breastfeed + people
Breastfeed + person
Breastfeeding people
Breastfeeding person
Chestfeed
Chestfeed + people
Chestfeed + person
Chestfeeding people
Clean energy
Climate crisis
Climate emergency
Climate science
Commercial sex worker
Community diversity
Community equity
Confirmation bias
Cultural
Cultural competence
Cultural differences
Cultural heritage
Cultural safety
Cultural sensitivity
Culturally
Culturally appropriate
Culturally responsive
Culture
Decolonize
Decolonized
Decolonizing
DEI
DEIA
DEIAB
DEIJ
Disabilities
Disability
Disabled
Discriminate
Discriminated
Discriminates
Discrimination
Discriminatory
Disparity
Diverse
Diverse backgrounds
Diverse communities
Diverse community
Diverse group
Diverse groups
Diversified
Diversify
Diversifying
Diversity
Enhance the diversity
Enhancing diversity
Environmental quality
Equal opportunity
Equality
Equitable
Equitableness
Equity
Ethnic
Ethnicity
Exclude
Excluded
Exclusion
Expression
Expressive
Expressiveness
Female
Females
Feminism
Feminist
Feminists
Foster
Fostering inclusivity
Gender
Gender affirming
Gender based
Gender based violence (GBV)
Gender diversity
Gender identity
Gender ideology
Gender-affirming
Genders
Global warming
Gulf of Mexico
Hate
Hate speech
Health disparity
Health equity
Health inequality
High-risk
Hispanic minority
Historically
Identifies
Identities
Identity
Immigrant
Immigrants
Implicit bias
Implicit biases
Inclusion
Inclusive
Inclusive leadership
Inclusiveness
Inclusivity
Increase diversity
Increase the diversity
Indigenous
Indigenous community
Inequalities
Inequality
Inequitable
Inequities
Inequity
Injustice
Institutional
Intersectional
Intersectionality
Key groups
Key people
Key populations
Latinx
LGBT
LGBTQ
LGBTQIA
Marginalize
Marginalized
Marginalizing
Men who have sex with men
Mental health
Minorities
Minority
Most risk
MSM
Multicultural
Multiculture
Multicultured
Mx
Mx.
Native American
Non binary
Nonbinary
Non-binary
Oppressed
Oppresses
Oppression
Oppressive
Orientation
Orientations
People + uterus
People centered
People-centered care
Person centered
Person-centered
Person-centered care
Polarization
Polarized
Polarizes
Political
Pollution
Population
Pregnant people
Pregnant person
Pregnant persons
Prejudice
Prejudiced
Prejudices
Privilege
Privileges
Priviliged
Promote diversity
Promoting diversity
Pronoun
Pronouns
Prostitute
Race
Race and ethnicity
Races
Racial
Racial diversity
Racial identity
Racial inequality
Racial justice
Racially
Racism
Segregated
Segregates
Segregation
Sense of belonging
Sex
Sexes
Sexual preferences
Sexuality
Social justice
Sociocultural
Socio-cultural
Socioeconomic
Socio-economic
Status
Statuses
Stereotype
Stereotypes
Stereotypical
Systemic
Systemically
They/them
Traditional
Traditions
Trans
Transgender
Transgendered
Transsexual
Trauma
Traumatic
Tribal
Unconscious bias
Underappreciated
Under-appreciated
Underprivileged
Under-priviliged
Underrepresentation
Under-representation
Underrepresented
Under-represented
Underserved
Under-served
Undervalued
Under-valued
Undocumented
Victim
Victimization
Victims
Vulnerable population
Vulnerable populations
Women
Women and underrepresented
Women who have sex with women
Womyn
`.trim().split('\n').map(line => line.trim()).filter(Boolean);

    const AI_TERMS = `
acknowledges
acknowledging
addresses
adept
adhered
adhering
advancement
advancements
advancing
advocates
advocating
affirming
afflicted
aiding
akin
align
aligning
aligns
alongside
amidst
assessments
attains
attributed
augmenting
avenue
avenues
bolster
bolstered
bolstering
broader
burgeoning
capabilities
capitalizing
categorized
categorizes
categorizing
combating
commendable
compelling
complicates
complicating
comprehending
comprising
consequently
consolidates
contributing
conversely
correlating
crafted
crafting
culminating
customizing
delineates
delve
delved
delves
delving
demonstrating
dependability
dependable
detailing
detrimentally
diminishes
diminishing
discern
discerned
discernible
discerning
displaying
disrupts
distinctions
distinctive
elevate
elevates
elevating
elucidate
elucidates
elucidating
embracing
emerges
emphasises
emphasising
emphasize
emphasizes
emphasizing
employing
employs
empowers
emulating
emulation
enabling
encapsulates
encompass
encompassed
encompasses
encompassing
endeavors
endeavours
enduring
enhancements
enhances
ensuring
equipping
escalating
evaluates
evolving
exacerbating
examines
exceeding
excels
exceptional
exceptionally
exerting
exhibiting
exhibits
expedite
expediting
exploration
explores
facilitated
facilitates
facilitating
featuring
formidable
fostering
fosters
foundational
furnish
garnered
garnering
gauged
grappling
groundbreaking
groundwork
harness
harnesses
harnessing
heighten
heightened
hinder
hinges
hinting
hold
holds
illuminates
illuminating
imbalances
impacting
impede
impeding
imperative
impressive
inadequately
incorporates
incorporating
influencing
inherent
initially
innovative
inquiries
integrates
integrating
integration
interconnectedness
interplay
intricacies
intricate
intricately
introduces
invaluable
investigates
involves
juxtaposed
leverages
leveraging
maintaining
merges
methodologies
meticulous
meticulously
multifaceted
necessitate
necessitates
necessitating
necessity
notable
noteworthy
nuanced
nuances
nytimes
offering
optimizing
orchestrating
outlines
overlook
overlooking
paving
perative
persist
pinpoint
pinpointed
pinpointing
pioneering
pioneers
pivotal
poised
pose
posed
poses
posing
predominantly
preserving
pressing
promise
pronounced
propelling
realm
realms
recognizing
refine
refines
refining
remarkable
renowned
revealing
reveals
revolutionize
revolutionizing
revolves
scrutinize
scrutinized
scrutinizing
seamless
seamlessly
seeks
serves
serving
shaping
shedding
showcased
showcases
showcasing
signifying
solidify
spanned
spanning
spurred
stands
stemming
strategically
streamline
streamlined
streamlines
streamlining
struggle
substantiated
substantiates
surged
surmount
surpass
surpassed
surpasses
surpassing
swift
swiftly
thorough
transformative
typically
ultimately
uncharted
uncovering
underexplored
underscore
underscored
underscores
underscoring
unexplored
unlocking
unparalleled
unraveling
unveil
unveiled
unveiling
unveils
uphold
upholding
urging
utilizes
varying
versatility
warranting
yielding
`.trim().split('\n').map(line => line.trim()).filter(Boolean);

    const TERM_GROUPS = {
      admin: ADMIN_TERMS,
      ai: AI_TERMS
    };

    const RESULT_GROUPS = [
      { key: 'admin', heading: 'Administration-Flagged Words & Phrases', label: 'Admin' },
      { key: 'ai', heading: 'Indicators of Artificial Intelligence Use', label: 'AI' }
    ];

    const RESULT_GROUP_LOOKUP = Object.fromEntries(RESULT_GROUPS.map(group => [group.key, group]));

    const termGroupInputs = Array.from(document.querySelectorAll('.term-group'));

    function expandTerm(term) {
      const trimmed = term.trim();
      if (!trimmed) return [];
      if (trimmed.includes(' + ')) {
        const collapsed = trimmed.replace(/\s*\+\s*/g, ' ').replace(/\s+/g, ' ').trim();
        return [trimmed, collapsed];
      }
      return [trimmed];
    }

    function gatherTerms(groups) {
      const bucket = new Map();
      groups.forEach(group => {
        const list = TERM_GROUPS[group] || [];
        list.forEach(term => {
          expandTerm(term).forEach(t => {
            if (!bucket.has(t)) {
              bucket.set(t, group);
            }
          });
        });
      });
      return Array.from(bucket.entries()).map(([term, group]) => ({ term, group }));
    }

    function escapeHTML(s) {
      return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
    }

    function buildRegex(term) {
      // escape regex special chars in term
      const esc = term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      return new RegExp(esc, 'gi');
    }

    const WORD_CHAR_RX = /[A-Za-z0-9]/;

    function needsStartBoundary(term) {
      return WORD_CHAR_RX.test(term[0] || '');
    }

    function needsEndBoundary(term) {
      return WORD_CHAR_RX.test(term[term.length - 1] || '');
    }

    function isWordChar(char) {
      return !!char && WORD_CHAR_RX.test(char);
    }

    function findMatches(text, term) {
      const rx = buildRegex(term);
      const matches = [];
      let m;
      let guard = 0;
      const enforceStart = needsStartBoundary(term);
      const enforceEnd = needsEndBoundary(term);
      while ((m = rx.exec(text))) {
        if (m[0].length === 0) { if (++guard > 1000) break; rx.lastIndex++; continue; }
        const start = m.index;
        const end = start + m[0].length;
        if (enforceStart && isWordChar(text[start - 1])) continue;
        if (enforceEnd && isWordChar(text[end])) continue;
        matches.push({ start, end });
      }
      return matches;
    }

    function makePlainSnippet(text) {
      return { html: escapeHTML(text), plain: text };
    }

    async function readFileAsArrayBuffer(file) {
      return new Promise((resolve, reject) => {
        const r = new FileReader();
        r.onerror = () => reject(r.error);
        r.onload = () => resolve(r.result);
        r.readAsArrayBuffer(file);
      });
    }

    async function extractTextFromDocx(file) {
      const arrayBuffer = await readFileAsArrayBuffer(file);
      const { value } = await window.mammoth.extractRawText({ arrayBuffer });
      return value || '';
    }

    async function extractTextFromXlsx(file) {
      const arrayBuffer = await readFileAsArrayBuffer(file);
      const wb = XLSX.read(arrayBuffer, { type: 'array' });
      let out = [];
      wb.SheetNames.forEach(name => {
        const ws = wb.Sheets[name];
        const csv = XLSX.utils.sheet_to_csv(ws, { blankrows: false });
        out.push(`\n\n=== SHEET: ${name} ===\n` + csv);
      });
      return out.join('\n');
    }

    function makeSnippets(text, term, context = 40, matches = null) {
      const hits = matches || findMatches(text, term);
      return hits.map(({ start, end }) => {
        const left = Math.max(0, start - context);
        const right = Math.min(text.length, end + context);
        const chunk = text.slice(left, right);
        const matchText = text.slice(start, end);
        const relativeStart = start - left;
        const relativeEnd = relativeStart + matchText.length;
        const before = chunk.slice(0, relativeStart);
        const after = chunk.slice(relativeEnd);
        const html = `â€¦${escapeHTML(before)}<mark>${escapeHTML(matchText)}</mark>${escapeHTML(after)}â€¦`;
        const plain = `â€¦${chunk}â€¦`;
        return { html, plain };
      });
    }

    function groupRowsByTerm(rows) {
      const groupMap = new Map();
      rows.forEach(row => {
        const groupKey = row.group;
        if (!groupMap.has(groupKey)) {
          groupMap.set(groupKey, new Map());
        }
        const termMap = groupMap.get(groupKey);
        const termKey = row.term;
        if (!termMap.has(termKey)) {
          termMap.set(termKey, { group: groupKey, term: termKey, total: 0, entries: [] });
        }
        const bucket = termMap.get(termKey);
        bucket.total += row.count;
        bucket.entries.push({ file: row.file, count: row.count, snips: row.snips });
      });

      const grouped = new Map();
      groupMap.forEach((termMap, groupKey) => {
        const buckets = Array.from(termMap.values()).map(bucket => {
          bucket.entries.sort((a, b) => {
            if (b.count !== a.count) return b.count - a.count;
            return String(a.file).localeCompare(String(b.file));
          });
          return bucket;
        });
        buckets.sort((a, b) => {
          if (b.total !== a.total) return b.total - a.total;
          return String(a.term).localeCompare(String(b.term));
        });
        grouped.set(groupKey, buckets);
      });

      return grouped;
    }

    function renderGroupPanel(heading, termBuckets) {
      if (!termBuckets.length) {
        return `<div class="panel"><div class="panel-title">${heading}</div><div class="note">No matches found in selected files.</div></div>`;
      }
      const head = `
        <thead><tr>
          <th style="width:32%">TERM</th>
          <th style="width:24%">FILE</th>
          <th style="width:12%">COUNT</th>
          <th>SNIPPETS</th>
        </tr></thead>`;
      const body = termBuckets.map(bucket => {
        const rows = bucket.entries.map((entry, idx) => {
          const fileCell = `<td>${escapeHTML(entry.file)}</td>`;
          const countCell = `<td><span class="pill ${entry.count>0?'ok':'bad'}">${entry.count}</span></td>`;
          const snippetsCell = `<td>${(entry.snips || []).map(s => `<code class="snip">${s.html}</code>`).join(' ')}</td>`;
          if (idx === 0) {
            const totalClass = bucket.total>0?'ok':'bad';
            const termCell = `<td rowspan="${bucket.entries.length}">${escapeHTML(bucket.term)} <span class="pill ${totalClass}">${bucket.total}</span></td>`;
            return `<tr>${termCell}${fileCell}${countCell}${snippetsCell}</tr>`;
          }
          return `<tr>${fileCell}${countCell}${snippetsCell}</tr>`;
        }).join('');
        return rows;
      }).join('');
      return `<div class="panel"><div class="panel-title">${heading}</div><table>${head}<tbody>${body}</tbody></table></div>`;
    }

    function renderResultsByGroup(groupedBuckets, selectedGroups) {
      const groupsInOrder = RESULT_GROUPS.filter(group => selectedGroups.includes(group.key));
      if (groupsInOrder.length === 0) {
        return '';
      }
      return groupsInOrder.map(group => {
        const termBuckets = groupedBuckets.get(group.key) || [];
        return renderGroupPanel(group.heading, termBuckets);
      }).join('');
    }

    async function analyze() {
      const selectedGroups = termGroupInputs.filter(cb => cb.checked).map(cb => cb.value);
      const termEntries = gatherTerms(selectedGroups);
      resultsDiv.innerHTML = '';
      if (termEntries.length === 0) {
        resultsDiv.innerHTML = `<div class="panel"><div class="note">Select at least one category to scan for keywords.</div></div>`;
        downloadReportBtn.disabled = true;
        latestReportRows = null;
        return;
      }

      btn.disabled = true; btn.textContent = 'Analyzingâ€¦';
      downloadReportBtn.disabled = true;
      latestReportRows = null;
      const chosen = fileBoxes.map(i => i.files?.[0]).filter(Boolean);
      if (chosen.length === 0) {
        resultsDiv.innerHTML = `<div class="panel"><div class="note">Add one or more files, then click <em>Analyze Files</em>.</div></div>`;
        btn.disabled = false; btn.textContent = 'Analyze Files';
        downloadReportBtn.disabled = true;
        return;
      }

      const rows = [];
      for (const file of chosen) {
        try {
          const ext = file.name.toLowerCase().split('.').pop();
          let text = '';
          if (ext === 'docx') text = await extractTextFromDocx(file);
          else if (ext === 'xlsx') text = await extractTextFromXlsx(file);
          else {
            rows.push({ file: file.name, term: '(unsupported)', count: 0, snips: [makePlainSnippet('Unsupported file type')], group: selectedGroups[0] || null });
            continue;
          }
          for (const { term, group } of termEntries) {
            const matches = findMatches(text, term);
            const count = matches.length;
            if (count > 0) {
              const snips = makeSnippets(text, term, 40, matches);
              rows.push({ file: file.name, term, count, snips, group });
            }
          }
        } catch (e) {
          rows.push({ file: file.name, term: '(error)', count: 0, snips: [makePlainSnippet(String(e.message || e))], group: selectedGroups[0] || null });
        }
      }

      const groupedBuckets = groupRowsByTerm(rows);
      resultsDiv.innerHTML = renderResultsByGroup(groupedBuckets, selectedGroups);

      const flattened = [];
      RESULT_GROUPS.filter(group => selectedGroups.includes(group.key)).forEach(group => {
        const buckets = groupedBuckets.get(group.key) || [];
        buckets.forEach(bucket => {
          bucket.entries.forEach(entry => {
            flattened.push({
              file: entry.file,
              term: bucket.term,
              group: bucket.group,
              count: entry.count,
              snips: entry.snips
            });
          });
        });
      });

      latestReportRows = flattened;
      downloadReportBtn.disabled = false;
      btn.disabled = false; btn.textContent = 'Analyze Files';
      resetBtn.disabled = false;
    }

    btn.addEventListener('click', analyze);
    resetBtn.addEventListener('click', () => {
      fileBoxes.forEach(input => { input.value = ''; });
      termGroupInputs.forEach(input => {
        input.checked = input.value === 'admin';
      });
      resultsDiv.innerHTML = '';
      btn.disabled = false;
      btn.textContent = 'Analyze Files';
      resetBtn.disabled = true;
      downloadReportBtn.disabled = true;
      latestReportRows = null;
    });
    downloadBtn.addEventListener('click', () => {
      const csvRows = [];
      const headers = ['Administration-Flagged Words & Phrases', 'Indicators of Artificial Intelligence Use'];
      csvRows.push(headers);
      const maxLen = Math.max(ADMIN_TERMS.length, AI_TERMS.length);
      for (let i = 0; i < maxLen; i++) {
        csvRows.push([
          ADMIN_TERMS[i] || '',
          AI_TERMS[i] || ''
        ]);
      }
      const csvContent = csvRows
        .map(row => row.map(cell => '"' + String(cell).replace(/"/g, '""') + '"').join(','))
        .join('\r\n');
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = 'keyword-lists.csv';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    });

    downloadReportBtn.addEventListener('click', () => {
      if (!latestReportRows) return;
      const csvRows = [];
      csvRows.push(['File', 'Term', 'Source', 'Count', 'Snippets']);
      if (latestReportRows.length === 0) {
        csvRows.push(['No matches found', '', '', '', '']);
      } else {
        latestReportRows.forEach(row => {
          const snippetText = (row.snips || []).map(s => s.plain).join(' | ');
          const sourceLabel = row.group ? (RESULT_GROUP_LOOKUP[row.group]?.label || row.group) : '';
          csvRows.push([
            row.file,
            row.term,
            sourceLabel,
            row.count,
            snippetText
          ]);
        });
      }
      const csvContent = csvRows
        .map(row => row.map(cell => '"' + String(cell).replace(/"/g, '""') + '"').join(','))
        .join('\r\n');
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = 'keyword-report.csv';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    });
  </script>
</body>
</html>
